#!/usr/bin/env python3
"""
VulnForge Exploit Testing Module
Validates and tests generated exploits
"""

import json
import logging
import subprocess
import tempfile
from pathlib import Path
from typing import Dict, List, Optional, Any
import docker
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn


class ExploitTester:
    def __init__(self, base_dir: Path):
        self.base_dir = base_dir
        self.logger = logging.getLogger(__name__)
        self.console = Console()
        self.test_dir = self.base_dir / "data" / "test_results"
        self.test_dir.mkdir(parents=True, exist_ok=True)

        # Initialize Docker client
        try:
            self.docker_client = docker.from_env()
        except Exception as e:
            self.logger.error(f"Failed to initialize Docker client: {e}")
            self.docker_client = None

    def test_exploit(self, exploit_path: Path, target_info: Dict) -> Dict[str, Any]:
        """Test an exploit against a target"""
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=self.console,
        ) as progress:
            # Validate exploit
            task = progress.add_task("Validating exploit...", total=None)
            validation = self._validate_exploit(exploit_path)
            if not validation["is_valid"]:
                return {
                    "success": False,
                    "error": "Exploit validation failed",
                    "validation": validation,
                }
            progress.update(task, completed=True)

            # Create test environment
            task = progress.add_task("Creating test environment...", total=None)
            try:
                test_env = self._create_test_environment(target_info)
                progress.update(task, completed=True)
            except Exception as e:
                self.logger.error(f"Failed to create test environment: {e}")
                return {
                    "success": False,
                    "error": f"Failed to create test environment: {str(e)}",
                }

            # Run exploit
            task = progress.add_task("Running exploit...", total=None)
            try:
                result = self._run_exploit(exploit_path, test_env)
                progress.update(task, completed=True)
            except Exception as e:
                self.logger.error(f"Failed to run exploit: {e}")
                return {"success": False, "error": f"Failed to run exploit: {str(e)}"}

            # Save test results
            task = progress.add_task("Saving test results...", total=None)
            result_path = self._save_test_results(result, exploit_path)
            progress.update(task, completed=True)

            return {"success": True, "result": result, "result_path": str(result_path)}

    def _validate_exploit(self, exploit_path: Path) -> Dict[str, Any]:
        """Validate exploit code"""
        validation = {
            "is_valid": False,
            "syntax_valid": False,
            "has_error_handling": False,
            "has_safety_warnings": False,
            "has_timeout": False,
            "has_input_validation": False,
            "has_logging": False,
            "has_safe_defaults": False,
            "issues": [],
        }

        try:
            # Read exploit code
            with open(exploit_path, "r") as f:
                code = f.read()

            # Check Python syntax
            compile(code, str(exploit_path), "exec")
            validation["syntax_valid"] = True

            # Check for error handling
            if "try:" in code and "except:" in code:
                validation["has_error_handling"] = True
            else:
                validation["issues"].append("Missing error handling")

            # Check for safety warnings
            if "WARNING" in code or "CAUTION" in code:
                validation["has_safety_warnings"] = True
            else:
                validation["issues"].append("Missing safety warnings")

            # Check for timeout
            if "timeout" in code:
                validation["has_timeout"] = True
            else:
                validation["issues"].append("Missing timeout mechanism")

            # Check for input validation
            if any(x in code for x in ["isinstance", "validate", "check"]):
                validation["has_input_validation"] = True
            else:
                validation["issues"].append("Missing input validation")

            # Check for logging
            if "logging" in code or "logger" in code:
                validation["has_logging"] = True
            else:
                validation["issues"].append("Missing logging")

            # Check for safe defaults
            if "default" in code and "safe" in code:
                validation["has_safe_defaults"] = True
            else:
                validation["issues"].append("Missing safe defaults")

            # Check for dangerous functions
            dangerous_funcs = ["eval", "exec", "os.system", "subprocess.call"]
            for func in dangerous_funcs:
                if func in code:
                    validation["issues"].append(f"Uses dangerous function: {func}")

            # Set overall validity
            validation["is_valid"] = (
                validation["syntax_valid"]
                and validation["has_error_handling"]
                and validation["has_safety_warnings"]
                and validation["has_timeout"]
                and validation["has_input_validation"]
                and validation["has_logging"]
                and validation["has_safe_defaults"]
                and not validation["issues"]
            )

        except SyntaxError as e:
            validation["issues"].append(f"Syntax error: {str(e)}")
        except Exception as e:
            validation["issues"].append(f"Validation error: {str(e)}")

        return validation

    def _create_test_environment(self, target_info: Dict) -> Dict[str, Any]:
        """Create isolated test environment"""
        if not self.docker_client:
            raise Exception("Docker client not available")

        # Create temporary directory for test files
        temp_dir = tempfile.mkdtemp()

        # Create Docker container
        container = self.docker_client.containers.run(
            image="python:3.9-slim",
            command="tail -f /dev/null",
            detach=True,
            remove=True,
            volumes={temp_dir: {"bind": "/test", "mode": "rw"}},
        )

        return {"container": container, "temp_dir": temp_dir}

    def _run_exploit(self, exploit_path: Path, test_env: Dict) -> Dict[str, Any]:
        """Run exploit in test environment"""
        container = test_env["container"]
        temp_dir = test_env["temp_dir"]

        # Copy exploit to container
        exploit_name = exploit_path.name
        container.put_archive("/test", exploit_path.read_bytes())

        # Run exploit
        try:
            result = container.exec_run(
                f"python3 /test/{exploit_name}", environment={"PYTHONUNBUFFERED": "1"}
            )

            return {
                "exit_code": result.exit_code,
                "output": result.output.decode(),
                "error": result.error.decode() if result.error else None,
            }

        finally:
            # Clean up
            container.stop()
            container.remove()

    def _save_test_results(self, result: Dict, exploit_path: Path) -> Path:
        """Save test results"""
        # Create results directory
        results_dir = self.test_dir / exploit_path.stem
        results_dir.mkdir(exist_ok=True)

        # Save results
        result_path = results_dir / "test_result.json"
        with open(result_path, "w") as f:
            json.dump(result, f, indent=2)

        return result_path

    def test_metasploit_module(
        self, module_path: Path, target_info: Dict
    ) -> Dict[str, Any]:
        """Test a Metasploit module"""
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=self.console,
        ) as progress:
            # Validate module
            task = progress.add_task("Validating Metasploit module...", total=None)
            validation = self._validate_metasploit_module(module_path)
            if not validation["is_valid"]:
                return {
                    "success": False,
                    "error": "Module validation failed",
                    "validation": validation,
                }
            progress.update(task, completed=True)

            # Create test environment
            task = progress.add_task(
                "Creating Metasploit test environment...", total=None
            )
            try:
                test_env = self._create_metasploit_environment(target_info)
                progress.update(task, completed=True)
            except Exception as e:
                self.logger.error(f"Failed to create Metasploit test environment: {e}")
                return {
                    "success": False,
                    "error": f"Failed to create Metasploit test environment: {str(e)}",
                }

            # Run module
            task = progress.add_task("Running Metasploit module...", total=None)
            try:
                result = self._run_metasploit_module(module_path, test_env)
                progress.update(task, completed=True)
            except Exception as e:
                self.logger.error(f"Failed to run Metasploit module: {e}")
                return {
                    "success": False,
                    "error": f"Failed to run Metasploit module: {str(e)}",
                }

            # Save test results
            task = progress.add_task("Saving test results...", total=None)
            result_path = self._save_test_results(result, module_path)
            progress.update(task, completed=True)

            return {"success": True, "result": result, "result_path": str(result_path)}

    def _validate_metasploit_module(self, module_path: Path) -> Dict[str, Any]:
        """Validate Metasploit module"""
        validation = {
            "is_valid": False,
            "has_metadata": False,
            "has_options": False,
            "has_check": False,
            "has_exploit": False,
            "has_payload": False,
            "issues": [],
        }

        try:
            # Read module code
            with open(module_path, "r") as f:
                code = f.read()

            # Check for metadata
            if "module_info" in code:
                validation["has_metadata"] = True
            else:
                validation["issues"].append("Missing module metadata")

            # Check for options
            if "register_options" in code:
                validation["has_options"] = True
            else:
                validation["issues"].append("Missing module options")

            # Check for check method
            if "def check" in code:
                validation["has_check"] = True
            else:
                validation["issues"].append("Missing check method")

            # Check for exploit method
            if "def exploit" in code:
                validation["has_exploit"] = True
            else:
                validation["issues"].append("Missing exploit method")

            # Check for payload handling
            if "payload" in code:
                validation["has_payload"] = True
            else:
                validation["issues"].append("Missing payload handling")

            # Set overall validity
            validation["is_valid"] = (
                validation["has_metadata"]
                and validation["has_options"]
                and validation["has_check"]
                and validation["has_exploit"]
                and validation["has_payload"]
                and not validation["issues"]
            )

        except Exception as e:
            validation["issues"].append(f"Validation error: {str(e)}")

        return validation

    def _create_metasploit_environment(self, target_info: Dict) -> Dict[str, Any]:
        """Create Metasploit test environment"""
        if not self.docker_client:
            raise Exception("Docker client not available")

        # Create temporary directory for test files
        temp_dir = tempfile.mkdtemp()

        # Create Docker container with Metasploit
        container = self.docker_client.containers.run(
            image="metasploitframework/metasploit-framework:latest",
            command="tail -f /dev/null",
            detach=True,
            remove=True,
            volumes={temp_dir: {"bind": "/test", "mode": "rw"}},
        )

        return {"container": container, "temp_dir": temp_dir}

    def _run_metasploit_module(
        self, module_path: Path, test_env: Dict
    ) -> Dict[str, Any]:
        """Run Metasploit module in test environment"""
        container = test_env["container"]
        temp_dir = test_env["temp_dir"]

        # Copy module to container
        module_name = module_path.name
        container.put_archive("/test", module_path.read_bytes())

        # Run module
        try:
            # Load module
            result = container.exec_run(
                f"msfconsole -q -x 'use /test/{module_name}; check; exit'"
            )

            return {
                "exit_code": result.exit_code,
                "output": result.output.decode(),
                "error": result.error.decode() if result.error else None,
            }

        finally:
            # Clean up
            container.stop()
            container.remove()
