"""
Exploit Module for NeuroRift
Handles vulnerability mapping, exploit generation, and testing orchestration.
"""

import asyncio
import logging
import json
from pathlib import Path
from typing import Optional, Dict, Any, List
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn

from modules.cve_collector.cve_collector import CVECollector
from modules.exploit_generator.exploit_generator import ExploitGenerator
from modules.exploit_testing.exploit_testing import ExploitTester

class ExploitModule:
    def __init__(self, base_dir: Path, ai_analyzer: Any):
        self.base_dir = base_dir
        self.ai_analyzer = ai_analyzer
        self.logger = logging.getLogger(__name__)
        self.console = Console()
        
        # Initialize sub-modules
        self.cve_collector = CVECollector(base_dir, ai_wrapper=ai_analyzer.ollama)
        # ExploitGenerator expects a 'llm_engine' which has a 'query' method.
        # Our ai_analyzer has an 'ollama' attribute which is an instance of OllamaClient.
        # OllamaClient has a 'generate' method, but ExploitGenerator uses 'query'.
        # I'll create a simple wrapper or check if ai_analyzer itself can be used.
        self.exploit_generator = ExploitGenerator(base_dir, ai_analyzer.ollama)
        self.exploit_tester = ExploitTester(base_dir)

    async def run_exploit_pipeline(self, target: str, recon_data: Dict[str, Any], output_dir: Optional[Path] = None, use_ai: bool = True) -> Dict[str, Any]:
        """
        Run the complete exploit pipeline: CVE Mapping -> Selection -> Generation -> Testing (Optional)
        """
        self.logger.info("Starting exploit pipeline for %s", target)
        
        results = {
            "target": target,
            "vulnerabilities": [],
            "exploits": [],
            "ai_decisions": {},
            "errors": []
        }

        try:
            with Progress(
                SpinnerColumn(),
                TextColumn("[progress.description]{task.description}"),
                console=self.console
            ) as progress:
                # 1. CVE Collection
                task = progress.add_task("Collecting vulnerability data (CVECollector)...", total=None)
                # CVECollector.search_cves might need specific recon info (service, version)
                # Let's try to map recon services to CVE searches
                vulns = await self._map_vulnerabilities(recon_data)
                results["vulnerabilities"] = vulns
                progress.update(task, completed=True)

                if not vulns:
                    self.console.print("[yellow]No vulnerabilities identified to exploit.[/yellow]")
                    return results

                # 2. AI Exploit Selection/Orchestration
                if use_ai:
                    task = progress.add_task("AI selecting best exploit candidates...", total=None)
                    selected_vulns = await self._ai_select_exploits(target, vulns)
                    results["ai_decisions"]["selected"] = selected_vulns
                    progress.update(task, completed=True)
                else:
                    selected_vulns = vulns[:3] # Default to top 3 if AI is off

                # 3. Exploit Generation
                task = progress.add_task("Generating exploits (ExploitGenerator)...", total=None)
                for vuln in selected_vulns:
                    exploit = await self.exploit_generator.generate_exploit(vuln, recon_data)
                    results["exploits"].append(exploit)
                progress.update(task, completed=True)

            return results

        except Exception as e:
            self.logger.error("Error during exploit pipeline: %s", e)
            results["errors"].append(str(e))
            return results

    async def _map_vulnerabilities(self, recon_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Map recon results to CVEs"""
        vulnerabilities = []
        services = recon_data.get("services", [])
        
        for service in services:
            name = service.get("name")
            version = service.get("version")
            if name:
                query = f"{name} {version}" if version else name
                # CVECollector might not be async, but we wrap it for consistency
                cves = await self.cve_collector.search_cves(query)
                if cves:
                    # Filter and format
                    for cve in cves[:5]: # Take top 5 per service
                        vulnerabilities.append({
                            "cve_id": cve.get("id"),
                            "description": cve.get("description"),
                            "affected_software": name,
                            "cvss_score": cve.get("score"),
                            "service_info": service
                        })
        
        return vulnerabilities

    async def _ai_select_exploits(self, target: str, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Use AI to select the most viable exploits to generate"""
        prompt = f"""
        Analyze the following vulnerabilities found on target: {target}
        
        Vulnerabilities:
        {json.dumps(vulnerabilities, indent=2)}
        
        Select the top 3 most promising and viable vulnerability for exploit generation.
        Consider CVSS score, reliability of POCs, and relevance to the target service.
        
        Return the selection as a JSON array of the original vulnerability objects.
        """
        
        system_prompt = "You are an exploit orchestration expert. Select the best candidates for exploit generation."
        
        try:
            response = await self.ai_analyzer.ollama.generate(prompt, system_prompt=system_prompt)
            if response:
                import re
                try:
                    return json.loads(response)
                except json.JSONDecodeError:
                    json_match = re.search(r'\[.*\]', response, re.DOTALL)
                    if json_match:
                        return json.loads(json_match.group(0))
            return vulnerabilities[:3]
        except Exception as e:
            self.logger.error("Error during AI exploit selection: %s", e)
            return vulnerabilities[:3]
