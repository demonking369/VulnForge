#!/usr/bin/env python3
"""
VulnForge Exploit Generator Module
Generates and validates exploits using AI
"""

import json
import logging
from pathlib import Path
from typing import Dict, List, Optional, Any
import ast
import re
from datetime import datetime
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn


class ExploitGenerator:
    def __init__(self, base_dir: Path, llm_engine: Any):
        self.base_dir = base_dir
        self.llm = llm_engine
        self.logger = logging.getLogger(__name__)
        self.console = Console()
        self.exploit_dir = self.base_dir / "data" / "exploit_db"
        self.template_dir = self.base_dir / "templates" / "exploits"
        self.exploit_dir.mkdir(parents=True, exist_ok=True)
        self.template_dir.mkdir(parents=True, exist_ok=True)

        # Load exploit templates
        self.templates = self._load_templates()

    def _load_templates(self) -> Dict[str, str]:
        """Load exploit templates"""
        templates = {}
        try:
            for template_file in self.template_dir.glob("*.py"):
                with open(template_file, "r") as f:
                    templates[template_file.stem] = f.read()
        except Exception as e:
            self.logger.error(f"Error loading templates: {e}")
        return templates

    def generate_exploit(self, cve_data: Dict, recon_data: Dict) -> Dict[str, Any]:
        """Generate exploit based on CVE and recon data"""
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=self.console,
        ) as progress:
            # Prepare prompt with context
            task = progress.add_task("Preparing exploit generation...", total=None)
            prompt = self._build_exploit_prompt(cve_data, recon_data)
            progress.update(task, completed=True)

            # Get AI response
            task = progress.add_task("Generating exploit code...", total=None)
            try:
                response = self.llm.query(
                    prompt=prompt,
                    system_prompt="""You are a security researcher creating proof-of-concept exploit code.
                    Generate safe, educational exploit code with proper error handling and comments.
                    Include safety warnings and ethical use disclaimers.
                    Follow these guidelines:
                    1. Use proper error handling with try/except blocks
                    2. Add detailed comments explaining the exploit
                    3. Include safety warnings and ethical use disclaimers
                    4. Make the code modular and readable
                    5. Add timeout and connection limits
                    6. Validate all user input
                    7. Use safe defaults
                    8. Include proper logging""",
                )
                progress.update(task, completed=True)
            except Exception as e:
                self.logger.error(f"Error generating exploit: {e}")
                return {"error": f"Failed to generate exploit: {str(e)}"}

            if not response:
                return {"error": "Failed to generate exploit - empty response"}

            # Parse and validate the response
            task = progress.add_task("Validating exploit code...", total=None)
            exploit_data = self._parse_exploit_response(response)
            if not exploit_data:
                return {"error": "Failed to parse exploit response"}

            # Validate exploit safety
            validation = self.validate_exploit(exploit_data)
            if validation["issues"]:
                self.logger.warning(
                    f"Exploit validation issues: {validation['issues']}"
                )
                exploit_data["validation"] = validation

            # Save the exploit
            task = progress.add_task("Saving exploit...", total=None)
            exploit_path = self._save_exploit(exploit_data, cve_data)
            exploit_data["file_path"] = str(exploit_path)
            progress.update(task, completed=True)

            return exploit_data

    def _build_exploit_prompt(self, cve_data: Dict, recon_data: Dict) -> str:
        """Build prompt for exploit generation"""
        # Get appropriate template
        template = self.templates.get("base", "")

        return f"""
        Generate a proof-of-concept exploit for this vulnerability:
        
        CVE: {cve_data.get('cve_id', 'Unknown')}
        Description: {cve_data.get('description', 'Unknown')}
        Affected Software: {cve_data.get('affected_software', 'Unknown')}
        CVSS Score: {cve_data.get('cvss_score', 'Unknown')}
        
        Target Information:
        - IP: {recon_data.get('ip', 'Unknown')}
        - Port: {recon_data.get('port', 'Unknown')}
        - Service: {recon_data.get('service', 'Unknown')}
        - Version: {recon_data.get('version', 'Unknown')}
        
        Requirements:
        1. Include proper error handling with try/except blocks
        2. Add detailed comments explaining the exploit
        3. Include safety warnings and ethical use disclaimers
        4. Make the code modular and readable
        5. Add timeout and connection limits
        6. Validate all user input
        7. Use safe defaults
        8. Include proper logging
        
        Use this template as a base:
        {template}
        
        Generate complete, working Python code:
        """

    def _parse_exploit_response(self, response: str) -> Optional[Dict]:
        """Parse and validate exploit response"""
        try:
            # Extract code block if present
            code_match = re.search(r"```(?:python)?\n(.*?)\n```", response, re.DOTALL)
            if code_match:
                code = code_match.group(1)
            else:
                code = response

            # Validate Python syntax
            ast.parse(code)

            # Extract metadata
            metadata = {
                "code": code,
                "generated_at": datetime.now().isoformat(),
                "language": "python",
                "type": "poc",
                "metadata": {},
            }

            # Extract CVE ID
            cve_match = re.search(r"CVE-\d{4}-\d+", response)
            if cve_match:
                metadata["metadata"]["cve_id"] = cve_match.group(0)

            # Extract author
            author_match = re.search(r"Author:\s*(.*?)(?:\n|$)", response)
            if author_match:
                metadata["metadata"]["author"] = author_match.group(1).strip()

            # Extract description
            desc_match = re.search(
                r"Description:\s*(.*?)(?:\n\n|\Z)", response, re.DOTALL
            )
            if desc_match:
                metadata["metadata"]["description"] = desc_match.group(1).strip()

            # Extract requirements
            req_match = re.search(
                r"Requirements:\s*(.*?)(?:\n\n|\Z)", response, re.DOTALL
            )
            if req_match:
                metadata["metadata"]["requirements"] = req_match.group(1).strip()

            # Extract references
            ref_match = re.search(
                r"References:\s*(.*?)(?:\n\n|\Z)", response, re.DOTALL
            )
            if ref_match:
                metadata["metadata"]["references"] = ref_match.group(1).strip()

            return metadata

        except SyntaxError as e:
            self.logger.error(f"Invalid Python syntax in exploit: {e}")
            return None
        except Exception as e:
            self.logger.error(f"Error parsing exploit response: {e}")
            return None

    def _save_exploit(self, exploit_data: Dict, cve_data: Dict) -> Path:
        """Save exploit to file"""
        cve_id = cve_data.get("cve_id", "unknown")
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{cve_id}_{timestamp}.py"
        filepath = self.exploit_dir / filename

        # Add metadata as comments
        metadata = {
            "cve_id": cve_id,
            "generated_at": exploit_data["generated_at"],
            "type": exploit_data["type"],
            **exploit_data.get("metadata", {}),
        }

        content = f"""#!/usr/bin/env python3
# VulnForge Generated Exploit
# CVE: {metadata['cve_id']}
# Generated: {metadata['generated_at']}
# Type: {metadata['type']}
# Author: {metadata.get('author', 'VulnForge')}
# Description: {metadata.get('description', 'No description available')}
# Requirements: {metadata.get('requirements', 'No requirements specified')}
# References: {metadata.get('references', 'No references provided')}
# WARNING: For educational purposes only. Use responsibly.

{exploit_data['code']}
"""

        with open(filepath, "w") as f:
            f.write(content)

        return filepath

    def generate_metasploit_module(self, exploit_data: Dict) -> Optional[Path]:
        """Generate Metasploit module from exploit"""
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=self.console,
        ) as progress:
            task = progress.add_task("Converting to Metasploit module...", total=None)

            # Get Metasploit template
            template = self.templates.get("metasploit", "")

            prompt = f"""
            Convert this Python exploit to a Metasploit module:
            
            {exploit_data['code']}
            
            Use this template as a base:
            {template}
            
            Requirements:
            1. Follow Metasploit module structure
            2. Include proper metadata
            3. Add error handling
            4. Include documentation
            5. Add proper options
            6. Include check method
            7. Add proper payload handling
            """

            try:
                response = self.llm.query(
                    prompt=prompt,
                    system_prompt="""You are a Metasploit module developer.
                    Convert exploits to proper Metasploit module format.
                    Follow Metasploit module best practices.""",
                )
                progress.update(task, completed=True)
            except Exception as e:
                self.logger.error(f"Error generating Metasploit module: {e}")
                return None

            if not response:
                return None

            # Save Metasploit module
            cve_id = exploit_data.get("metadata", {}).get("cve_id", "unknown")
            filename = f"{cve_id}.rb"
            filepath = self.exploit_dir / "metasploit" / filename
            filepath.parent.mkdir(exist_ok=True)

            with open(filepath, "w") as f:
                f.write(response)

            return filepath

    def validate_exploit(self, exploit_data: Dict) -> Dict[str, Any]:
        """Validate generated exploit"""
        validation = {
            "syntax_valid": False,
            "has_error_handling": False,
            "has_safety_warnings": False,
            "has_timeout": False,
            "has_input_validation": False,
            "has_logging": False,
            "has_safe_defaults": False,
            "issues": [],
        }

        try:
            # Check Python syntax
            ast.parse(exploit_data["code"])
            validation["syntax_valid"] = True

            # Check for error handling
            if "try:" in exploit_data["code"] and "except:" in exploit_data["code"]:
                validation["has_error_handling"] = True
            else:
                validation["issues"].append("Missing error handling")

            # Check for safety warnings
            if "WARNING" in exploit_data["code"] or "CAUTION" in exploit_data["code"]:
                validation["has_safety_warnings"] = True
            else:
                validation["issues"].append("Missing safety warnings")

            # Check for timeout
            if "timeout" in exploit_data["code"]:
                validation["has_timeout"] = True
            else:
                validation["issues"].append("Missing timeout mechanism")

            # Check for input validation
            if any(
                x in exploit_data["code"] for x in ["isinstance", "validate", "check"]
            ):
                validation["has_input_validation"] = True
            else:
                validation["issues"].append("Missing input validation")

            # Check for logging
            if "logging" in exploit_data["code"] or "logger" in exploit_data["code"]:
                validation["has_logging"] = True
            else:
                validation["issues"].append("Missing logging")

            # Check for safe defaults
            if "default" in exploit_data["code"] and "safe" in exploit_data["code"]:
                validation["has_safe_defaults"] = True
            else:
                validation["issues"].append("Missing safe defaults")

            # Check for dangerous functions
            dangerous_funcs = ["eval", "exec", "os.system", "subprocess.call"]
            for func in dangerous_funcs:
                if func in exploit_data["code"]:
                    validation["issues"].append(f"Uses dangerous function: {func}")

        except SyntaxError as e:
            validation["issues"].append(f"Syntax error: {str(e)}")

        return validation
